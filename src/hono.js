var A=Object.defineProperty,O=Object.defineProperties;var I=Object.getOwnPropertyDescriptors;var E=Object.getOwnPropertySymbols;var B=Object.prototype.hasOwnProperty,D=Object.prototype.propertyIsEnumerable;var v=(n,e,t)=>e in n?A(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,f=(n,e)=>{for(var t in e||(e={}))B.call(e,t)&&v(n,t,e[t]);if(E)for(var t of E(e))D.call(e,t)&&v(n,t,e[t]);return n},P=(n,e)=>O(n,I(e));var F=/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,w=n=>{let e=n.split(/\//);return e[0]===""&&e.shift(),e},L=n=>{let e=n.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);return e?e[2]?[e[1],"("+e[2]+")"]:[e[1],"(.+)"]:null},N=n=>{let e=n.match(F);return e?e[5]:""},_=n=>{let e=n.match(F);return!!(e&&e[1])};var G="ALL",k=class{constructor(e,t){this.handler=e,this.params=t}},H=()=>null,g=class{constructor(e,t,r){this.children=r||{},this.method={},e&&t&&(this.method[e]=t),this.middlewares=[]}insert(e,t,r){let s=this,u=w(t);for(let o=0,a=u.length;o<a;o++){let i=u[o];if(Object.keys(s.children).includes(i)){s=s.children[i];continue}s.children[i]=new g,s=s.children[i]}return s.method[e]=r,s}search(e,t){let r=this,s={},u=w(t);for(let a=0,i=u.length;a<i;a++){let p=u[a];if(r.children["*"]&&!r.children[p]){let c=r.children["*"];if(Object.keys(c.children).length===0){r=c;break}}let m=r.children[p];if(m&&(r=m,!(a==i-1&&m.children["*"])))continue;let l=!1,d=!1,h=Object.keys(r.children);for(let c=0,U=h.length;c<U;c++){let y=h[c];if(y==="*"){r=r.children["*"],l=!0;break}let T=L(y);if(T){let x=p.match(new RegExp(T[1]));if(x){let j=T[0];s[j]=x[1],r=r.children[y],d=!0;break}return H()}}if(l&&a===i-1)break;if(l===!1&&d===!1)return H()}let o=r.method[G]||r.method[e];return o?new k(o,s):H()}};var C=n=>{let e=[];return function(t,r){let s=-1;return u(0);async function u(o){if(o<=s)return Promise.reject(new Error("next() called multiple times"));s=o;let a=n[o];if(o===n.length&&(a=r),!a)return Promise.resolve();try{return Promise.resolve(a(t,u.bind(null,o+1))).catch(i=>{throw e.push(i),e[0]})}catch(i){return Promise.reject(i)}}}};var M=n=>W[n],W={200:"OK",201:"Created",202:"Accepted",204:"No Content",206:"Partial Content",301:"Moved Permanently",302:"Moved Temporarily",303:"See Other",304:"Not Modified",307:"Temporary Redirect",308:"Permanent Redirect",400:"Bad Request",401:"Unauthorized",402:"Payment Required",403:"Forbidden",404:"Not Found",405:"Not Allowed",406:"Not Acceptable",408:"Request Time-out",409:"Conflict",410:"Gone",411:"Length Required",412:"Precondition Failed",413:"Request Entity Too Large",414:"Request-URI Too Large",415:"Unsupported Media Type",416:"Requested Range Not Satisfiable",421:"Misdirected Request",429:"Too Many Requests",500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",503:"Service Temporarily Unavailable",504:"Gateway Time-out",505:"HTTP Version Not Supported",507:"Insufficient Storage"};var R=class{constructor(e,t){this.req=e,t&&(this.res=t.res,this.env=t.env,this.event=t.event),this._headers={}}header(e,t){this.res&&this.res.headers.set(e,t),this._headers[e]=t}status(e){if(this.res){console.warn("c.res.status is already set.");return}this._status=e,this._statusText=M(e)}newResponse(e,t={}){t.status=t.status||this._status,t.statusText=t.statusText||this._statusText,t.headers=f(f({},this._headers),t.headers);let r=0;return e&&(e instanceof ArrayBuffer?r=e.byteLength:typeof e=="string"&&(r=new TextEncoder().encode(e).byteLength||0)),t.headers=P(f({},t.headers),{"Content-Length":r.toString()}),new Response(e,t)}body(e,t=this._status,r=this._headers){return this.newResponse(e,{status:t,headers:r})}text(e,t=this._status,r={}){if(typeof e!="string")throw new TypeError("text method arg must be a string!");return r["Content-Type"]||(r["Content-Type"]="text/plain; charset=UTF-8"),this.body(e,t,r)}json(e,t=this._status,r={}){if(typeof e!="object")throw new TypeError("json method arg must be a object!");let s=JSON.stringify(e);return r["Content-Type"]||(r["Content-Type"]="application/json; charset=UTF-8"),this.body(s,t,r)}html(e,t=this._status,r={}){if(typeof e!="string")throw new TypeError("html method arg must be a string!");return r["Content-Type"]||(r["Content-Type"]="text/html; charset=UTF-8"),this.body(e,t,r)}redirect(e,t=302){if(typeof e!="string")throw new TypeError("location must be a string!");if(!_(e)){let r=new URL(this.req.url);r.pathname=e,e=r.toString()}return this.newResponse(null,{status:t,headers:{Location:e}})}};var q="ALL",b=class{constructor(){this.node=new g}add(e,t,r){this.node.insert(e,t,r)}match(e,t){return this.node.search(e,t)}},S=class{constructor(){this.router=new b,this.middlewareRouters=[],this.tempPath="/"}get(e,...t){return this.addRoute("get",e,...t)}post(e,...t){return this.addRoute("post",e,...t)}put(e,...t){return this.addRoute("put",e,...t)}head(e,...t){return this.addRoute("head",e,...t)}delete(e,...t){return this.addRoute("delete",e,...t)}options(e,...t){return this.addRoute("options",e,...t)}patch(e,...t){return this.addRoute("patch",e,...t)}all(e,...t){return this.addRoute("all",e,...t)}route(e){return this.tempPath=e,this}use(e,t){if(t.constructor.name!=="AsyncFunction")throw new TypeError("middleware must be a async function!");let r=new b;r.add(q,e,t),this.middlewareRouters.push(r)}addRoute(e,t,...r){return e=e.toUpperCase(),typeof t=="string"?(this.tempPath=t,this.router.add(e,t,r)):(r.unshift(t),this.router.add(e,this.tempPath,r)),this}async matchRoute(e,t){return this.router.match(e,t)}async dispatch(e,t,r){let[s,u]=[e.method,N(e.url)],o=await this.matchRoute(s,u);e.param=d=>{if(o)return o.params[d]},e.header=d=>e.headers.get(d),e.query=d=>new URL(l.req.url).searchParams.get(d);let a=o?o.handler[0]:this.notFound,i=[];for(let d of this.middlewareRouters){let h=d.match(q,u);h&&i.push(h.handler)}let p=async(d,h)=>{let c=await a(d);if(!(c instanceof Response))throw new TypeError("response must be a instace of Response");d.res=c,await h()};i.push(p);let m=C(i),l=new R(e,{env:t,event:r,res:null});return await m(l),l.res}async handleEvent(e){return this.dispatch(e.request,{},e).catch(t=>this.onError(t))}async fetch(e,t,r){return this.dispatch(e,t,r).catch(s=>this.onError(s))}fire(){addEventListener("fetch",e=>{e.respondWith(this.handleEvent(e))})}onError(e){console.error(`${e}`);let t="Internal Server Error";return new Response(t,{status:500,headers:{"Content-Length":t.length.toString()}})}notFound(){let e="Not Found";return new Response(e,{status:404,headers:{"Content-Length":e.length.toString()}})}};export{R as Context,S as Hono};
